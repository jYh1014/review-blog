### 浏览器渲染原理

- 首先，浏览器将从服务器返回回来的html文档构建成dom tree（典型的栈结构），是从上到下依次解析。这个html原本是二进制格式的，需要先根据编码格式（比如utf-8）来转换为字符串，然后根据词法分析生成token，这个token就是一个不可再分的最小单元。每个token
- 解析css，构建cssom规则树。
- 将dom tree 和cssom合并构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。注意：1和2两个步骤是可以同时进行的，也就是说cssom的构建不影响dom tree 的构建，但是会影响最终渲染树的构建。
- 进行布局，也就是说为每一个渲染对象计算出具体的位置和大小。也就是重排
- 绘制，遍历渲染树的节点，调用渲染节点的paint方法进行绘制，重绘。
- 注意：并不是要等到整个html都解析完才呈现到页面上，为了更好的体验，浏览器渲染引擎是解析一点就显示一部分内容。
- 在解析时会预先扫描css和js文件进行提前加载。

#### 在文档解析过程中遇到js脚本的情况

- 首先，原本没有js脚本的情况下， cssom是不会阻塞文档的解析的，但是遇到js脚本后情况就变了。由于js脚本里面可能有更改样式的行为，所以js脚本的执行要延迟等到cssom构建完成后才能执行，这样一来，就是先构建cssom，然后执行js脚本，等js执行结束后最后从中断的地方接着解析html文档。也就是说js脚本的加载、解析与执行都会阻塞文档的解析。
- 所以我们建议js脚本要尽量放到body的最下面，这样，能尽量少的阻塞文档的解析。
- 由于js引擎线程和GUI渲染引擎线程是互斥的，我们可以利用defer或者async属性来进行优化。
- preload或者prefetch
- 
#### defer和async的作用和区别
- 在不加这两个属性之前，js脚本加载完就开始执行，执行会阻塞html文档的解析
- defer表示延迟执行js脚本，即这段js脚本加载的同时，文档也可以进行解析。最后js脚本要等到文档解析完成后，在 DOMContentLoaded 事件触发之前完成。多个脚本会按顺序执行。
- async表示异步加载js脚本，加载完就立刻执行，加载过程的同时不会阻塞文档的解析，但是执行过程会阻塞。多个脚本的执行顺序无法保证。会在load之前完成，但是和DOMContentLoaded事件前后触发并不确定。

#### 重排和重绘
- 重排：当渲染树重的某些元素因为尺寸大小、位置、是否隐藏等改变而需要重新构建的操作，也就是会影响布局的操作称为重排。
- 重绘：只是更改元素的外观风格等属性，并没有引起布局的变化。

#### 常见的引起重排的方法：
- 添加或者删除可见的 DOM 元素
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在 input 框中输入文字
- 浏览器窗口尺寸改变——resize事件发生时
- 计算 offsetWidth 和 offsetHeight 、clientHeight等属性
- display
- 修改字体
- 重排必定会触发重绘，但是重绘不一定会触发重排。重排的成本比较高。

#### 为什么css要尽量放到顶部

- 如果放到页面底部，那可能会导致重排或者重绘。

#### DOMContentLoaded 事件和 Load 事件的区别？
- DOMContentLoaded是html文档解析完成就会触发，不用等待js脚本样式文件图片等的加载。
- load是所有的资源都要加载完成。

#### 如何优化关键路径渲染
- 关键路径：其实就是渲染的流程
- 为了尽快完成首屏的渲染，我们需要最大限度减小这三个可变因素。
  - 关键资源的数量：可能阻塞网页首次渲染的资源的数量要尽可能少。
  - 关键路径长度：获取资源所需的往返次数或者总时间。
  - 关键字节：首次渲染所需的字节总数，也就是总的资源文件大小。采取压缩。
- 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。
- 优化关键字节数以缩短下载时间（往返次数）
- 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。
