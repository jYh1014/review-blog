#### 为什么需要垃圾回收
- 首先说一下v8引擎对js代码执行的过程。当一个函数执行的时候，会将当前执行上下文压入执行栈，当函数执行完毕后会从栈顶弹出函数的执行上下文，执行上下文中包括函数作用域，也就是说函数内部的变量也会被自动回收。如果在函数执行结束后，里面的变量并没有被回收，一直占用内存，那程序的性能会受到很大影响。
- js是单线程的，在进行垃圾回收的同时，js是不能同时进行别的执行任务的，也就是会处于阻塞状态。
- 
#### 垃圾回收的策略
- v8的垃圾回收策略主要是基于分代式垃圾回收机制，根据对象的存活时间来对内存的垃圾进行分代，然后根据不同的分代进行不同的策略处理。主要是分为新生代和老生代。
- 最早的有引用计数算法。就是看是否有对象被别的对象引用的次数为0.这个算法的缺点是不能处理循环引用的问题。
#### 新生代的垃圾回收
- 新生代里的内存空间比较小，适合存放一些存活时间短，小的对象。
- 新生代采取的是Scavenge算法，其中主要是复制式的Cheney算法。将堆内存区域一分为二，一部分是暂且还在使用状态的对象（from），另一部分是空闲区（to）；当进行垃圾回收时，会查看from区是否有存活对象，若有则会被复制到to区域，然后清除from区域所有的对象。然后from区域和to区域会做一次角色交换。
- 
#### 老生代的垃圾回收
- 如果一个对象在被复制多次后依旧存活，那它将会被认为是存活时间久的对象被放入老生代。
- 标记清除算法（Mark-Sweep）。会采取广度优先遍历的方法查看对象是否能访问到，若能则标记此对象是存活的，然后清除死亡的对象，此时会产生不连续的空闲的内存碎片。
- Mark-Compact(标记整理)。主要就是解决内存碎片的问题，会讲存活的对象移动到堆内存的左端，然后清除死亡对象。
























