#### 上拉加载

- 原理：监听滚动事件，然后在滚动过程中判断 当前列表被卷去的高度scrollTop + 容器的高度containerHeightHeight >= 内容高度scrollHeight。则应该加载更多数据。
- 优化：加防抖。

#### 下拉刷新
- 原理：首先记录一下最开始当前列表距离顶部的距离 original = element.offsetTop;然后给目标元素也就是当前列表添加touchStart事件，只有当前列表的offsetTop === original，并且被卷去的内容高度是0，先记录下此时纵坐标。
- 然后添加touchMove事件，在move事件的回调函数里 主要就是设置style.top值，也就是当前最新的纵坐标减去初始纵坐标 的值，记为distance
- 添加touchEnd事件，当distance的值大于比如30px，则开始执行刷新逻辑；然后开启一个定时器，每隔一段时间让element元素的top值减小也就是往回弹，一直到distance小于1就清除定时器。
- 优化：加节流，不能加防抖。因为防抖是松手后才有效果，而下拉过程是需要元素往下移动的。
```js
function downRefresh(element){
  let originalTop = element.offsetTop
  element.addEventListener("touchStart", function(event){
    if(element.offsetTop === originalTop && element.scrollTop == 0){
      let startY = event.touches[0].pageY
      element.addEventListener("touchMove", touchMove)
      element.addEventListener("touchEnd", touchEnd)
    }
    function touchMove(event){
      let pageY = event.touches[0].pageY
      if(pageY > startY){
        let distance = pageY - startY
        element.style.top = originalTop+distance+"px"
      }else{//移除事件监听}
    }
    function touchEnd(event){
    //清除move和start事件监听
      //回弹效果
      let timer = setInterval(()=>{
      if(distance < 1){清除定时器}
        element.style.top = --distance + "px"
      },20)
      if(distance > 30){
        ///执行刷新逻辑
      }
    }
  })
}
```
