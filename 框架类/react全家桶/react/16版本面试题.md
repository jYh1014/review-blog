### fiber

#### 为什么需要fiber？
- 我们所看到的页面是一帧一帧绘制出来的，普通设备屏幕的刷新频率是每秒 60次，也就是说当每秒绘制的帧数大于等于60时，页面是流畅的，否则将会感觉到卡顿。按照一秒60帧计算的话，那绘制一帧大约需要16ms左右。如果我们js代码执行时间过长又因为js引擎线程和页面渲染引擎是互斥的，那将会阻塞页面的渲染，使用户感觉到卡顿。
- 一帧中浏览器具体都做了哪些事情？
  - 首先是处理用户输入事件，让用户能够及时得到反馈。
  - 处理定时器，检查哪些定时器已经到时，然后执行这些定时器的回调。
  - 接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等。
  - 处理动画帧requestAnimationFrame
  - 重排（layout）
  - 绘制（paint）
  - 最后才处于空闲时间。
- react页面初次渲染以及更新时，是从根节点开始用深度优先遍历的算法进行递归遍历子节点的，期间不能中断，这样会造成执行栈比较深，而且如果项目很庞大的话，就容易造成js引擎线程一直占用着浏览器资源导致页面渲染引擎处于阻塞状态而出现卡顿现象。

#### 什么是fiber？
- 从数据结构的角度来说，每个虚拟dom节点都是一个fiber，里面存放着此节点的兄弟节点以及大儿子节点还有其父节点。所有的fiber节点组成一个单链表
- 从任务单元划分的角度来说，每个fiber都是一个小的任务单元，每次执行完一个单元都会询问浏览器是否有剩余时间，如果有则继续下一个fiber任务，如果没有则把控制权交还给浏览器。这样就能保证一帧时间内js引擎不会占用太多时间，而且还能中断，等浏览器执行完别的高优先级任务如果有剩余时间会接着执行下一个fiber任务。这点涉及到requestIdleCallback的理解。
  - requestIdleCallback是react fiber实现的基础，使用requestIdleCallback调度的任务单元说明优先级不是很高，每次都要先向浏览器申请时间片，浏览器执行完高优先级任务后若还有剩余时间则会给js引擎分配时间片，js执行完一个任务单元后会查看当前帧还是否有时间剩余，若有则继续执行下一个任务单元，否则将交出控制权让给浏览器，然后申请下一个时间片。
  ```js
  //所有的任务单元组成的数组
  const works = [
    ()=>{
    console.log("第一个任务")
    },
    ()=>{
    console.log("第二个任务")
    },
    ()=>{
    console.log("第三个任务")
    }
  ]
  function performUnitOfWork(){
    works.shift()()
  }
  //进入工作调度
  function workLoop(deadline){
    //如果当前帧还有剩余时间或者已经达到了限制的超时时间，如果达到了超时时间则必须强制执行此任务单元，不交出控制权。
    if((deadline.timeRemaining() > 1 || deadline.didTimeout) && works.length > 0){
      performUnitOfWork()
    }
    //否则若还有任务单元则申请下一个时间片
    if(works.length > 0){
      requestIdleCallback(workLoop)
    }
  }
  requestIdleCallback(workLoop)
  ```
